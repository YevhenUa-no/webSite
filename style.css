const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreElement = document.getElementById('score');
const highScoreElement = document.getElementById('highScore');
const gameOverMessage = document.getElementById('game-over-message');
const finalScoreElement = document.getElementById('finalScore');
const startButton = document.getElementById('start-button');
const controlsContainer = document.getElementById('controls-container');

const gridSize = 20;
let tileSize;

let snake;
let food;
let score;
let highScore = localStorage.getItem('snakeHighScore') || 0;
let direction;
let isGameOver = false;
let gameLoop;
let touchStartX = 0;
let touchStartY = 0;
let musicEnabled = true;

// Audio components
let pointSynth, buzzSynth, mainSynth;
let mainLoop;

// Single 8-bit song
const song = {
    name: "Tetris Theme",
    notes: ["E5", "B4", "C5", "D5", "C5", "B4", "A4", "A4", "C5", "E5", "D5", "C5", "B4"],
    durations: ["4n", "8n", "8n", "4n", "8n", "8n", "4n", "8n", "8n", "4n", "8n", "8n", "2n"],
    tempo: 120
};

highScoreElement.textContent = highScore;

function setupAudio() {
    // This function is now only called after a user interaction
    if (Tone.context.state !== 'running') {
        Tone.start();
    }

    // Main synth for background music
    mainSynth = new Tone.Synth({
        oscillator: { 
            type: "square8",
            modulationFrequency: 0.5
        },
        envelope: {
            attack: 0.02,
            decay: 0.1,
            sustain: 0.3,
            release: 0.8
        }
    }).chain(
        new Tone.Filter(800, "lowpass"),
        new Tone.Volume(-10),
        Tone.Destination
    );

    // Point sound effect
    pointSynth = new Tone.Synth({
        oscillator: { type: "triangle8" },
        envelope: {
            attack: 0.01,
            decay: 0.1,
            sustain: 0.05,
            release: 0.1
        }
    }).chain(
        new Tone.Volume(-8),
        Tone.Destination
    );

    // Game over sound effect
    buzzSynth = new Tone.Synth({
        oscillator: { type: "sawtooth4" },
        envelope: {
            attack: 0.01,
            decay: 1.5,
            sustain: 0,
            release: 0.1
        }
    }).chain(
        new Tone.Volume(-12),
        Tone.Destination
    );

    playCurrentSong();
}

function playCurrentSong() {
    if (!musicEnabled) return;

    if (mainLoop) mainLoop.dispose();

    Tone.Transport.bpm.value = song.tempo;

    mainLoop = new Tone.Sequence((time, note) => {
        if (note && musicEnabled) {
            mainSynth.triggerAttackRelease(note, "8n", time);
        }
    }, song.notes, "8n").start(0);
}

function toggleMusic() {
    musicEnabled = !musicEnabled;
    if (musicEnabled) {
        // If music is enabled, we start Tone and the loop
        if (Tone.context.state === 'suspended') {
            Tone.start();
        }
        if (Tone.Transport.state === 'stopped') {
            Tone.Transport.start();
        }
        playCurrentSong();
    } else {
        // If music is disabled, we dispose of the loop and stop the transport
        if (mainLoop) mainLoop.dispose();
        Tone.Transport.stop();
    }
}

// Function to set up the canvas dimensions responsively
function setupCanvas() {
    const size = Math.min(window.innerWidth * 0.8, window.innerHeight * 0.6, 500);
    canvas.width = size - (size % gridSize);
    canvas.height = size - (size % gridSize);
    tileSize = canvas.width / gridSize;
}

// Initial setup on window load
window.onload = () => {
    setupCanvas();
    startButton.addEventListener('click', startGame);
    window.addEventListener('resize', setupCanvas);
};

function startGame() {
    isGameOver = false;
    gameOverMessage.style.display = 'none';
    startButton.style.display = 'none';

    score = 0;
    scoreElement.textContent = score;

    // Initial snake state
    snake = [
        { x: Math.floor(gridSize/2), y: Math.floor(gridSize/2) },
        { x: Math.floor(gridSize/2) - 1, y: Math.floor(gridSize/2) }
    ];
    direction = { x: 1, y: 0 };

    placeFood();

    if (gameLoop) clearInterval(gameLoop);
    gameLoop = setInterval(gameTick, 120);

    // This is the key change for iOS: audio is now set up after the user clicks "Start Game"
    setupAudio();
    if (musicEnabled) {
        Tone.Transport.start();
    }
}

function placeFood() {
    food = {
        x: Math.floor(Math.random() * gridSize),
        y: Math.floor(Math.random() * gridSize)
    };

    // Ensure food doesn't spawn on the snake
    for (let segment of snake) {
        if (segment.x === food.x && segment.y === food.y) {
            placeFood();
            return;
        }
    }
}

function gameTick() {
    if (isGameOver) {
        return;
    }

    // Move the snake
    const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };
    snake.unshift(head);

    // Check for collision with food
    if (head.x === food.x && head.y === food.y) {
        score++;
        scoreElement.textContent = score;

        // Play point sound with pitch variation
        const pitches = ["C5", "D5", "E5", "F5", "G5"];
        const randomPitch = pitches[Math.floor(Math.random() * pitches.length)];
        pointSynth.triggerAttackRelease(randomPitch, "16n");

        placeFood();
    } else {
        snake.pop();
    }

    // Check for collisions
    if (head.x < 0 || head.x >= gridSize || head.y < 0 || head.y >= gridSize || checkSelfCollision()) {
        endGame();
    }

    drawGame();
}

function drawGame() {
    // Clear canvas with gradient effect
    const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
    gradient.addColorStop(0, 'rgba(15, 23, 42, 0.9)');
    gradient.addColorStop(1, 'rgba(30, 41, 59, 0.9)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw snake with glow effect
    snake.forEach((segment, index) => {
        // Glow effect
        ctx.shadowColor = '#10b981';
        ctx.shadowBlur = index === 0 ? 15 : 8;

        // Snake body gradient
        const segmentGradient = ctx.createRadialGradient(
            segment.x * tileSize + tileSize/2, segment.y * tileSize + tileSize/2, 0,
            segment.x * tileSize + tileSize/2, segment.y * tileSize + tileSize/2, tileSize/2
        );

        if (index === 0) {
            // Head is brighter
            segmentGradient.addColorStop(0, '#34d399');
            segmentGradient.addColorStop(1, '#10b981');
        } else {
            segmentGradient.addColorStop(0, '#10b981');
            segmentGradient.addColorStop(1, '#059669');
        }

        ctx.fillStyle = segmentGradient;
        ctx.fillRect(segment.x * tileSize + 1, segment.y * tileSize + 1, tileSize - 2, tileSize - 2);
    });

    // Draw food with pulsing effect
    ctx.shadowColor = '#ef4444';
    ctx.shadowBlur = 20;

    const foodGradient = ctx.createRadialGradient(
        food.x * tileSize + tileSize/2, food.y * tileSize + tileSize/2, 0,
        food.x * tileSize + tileSize/2, food.y * tileSize + tileSize/2, tileSize/2
    );
    foodGradient.addColorStop(0, '#f87171');
    foodGradient.addColorStop(1, '#dc2626');

    ctx.fillStyle = foodGradient;
    ctx.fillRect(food.x * tileSize + 2, food.y * tileSize + 2, tileSize - 4, tileSize - 4);

    // Reset shadow
    ctx.shadowBlur = 0;
}

function checkSelfCollision() {
    const head = snake[0];
    for (let i = 1; i < snake.length; i++) {
        if (head.x === snake[i].x && head.y === snake[i].y) {
            return true;
        }
    }
    return false;
}

function endGame() {
    isGameOver = true;
    clearInterval(gameLoop);

    // Update high score
    if (score > highScore) {
        highScore = score;
        highScoreElement.textContent = highScore;
        localStorage.setItem('snakeHighScore', highScore);
    }

    finalScoreElement.textContent = score;
    gameOverMessage.style.display = 'block';
    startButton.style.display = 'block';
    startButton.textContent = 'PLAY AGAIN';

    // Stop music and play game over sound
    Tone.Transport.stop();
    if (mainLoop) mainLoop.dispose();

    // Play a single, low buzz sound
    buzzSynth.triggerAttackRelease("C2", "1n");
}

// Handle keyboard input
document.addEventListener('keydown', e => {
    if (isGameOver) return;

    switch (e.key) {
        case 'ArrowUp':
        case 'w':
        case 'W':
            if (direction.y === 0) direction = { x: 0, y: -1 };
            break;
        case 'ArrowDown':
        case 's':
        case 'S':
            if (direction.y === 0) direction = { x: 0, y: 1 };
            break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
            if (direction.x === 0) direction = { x: -1, y: 0 };
            break;
        case 'ArrowRight':
        case 'd':
        case 'D':
            if (direction.x === 0) direction = { x: 1, y: 0 };
            break;
        case ' ':
            e.preventDefault();
            toggleMusic();
            break;
    }
});

// Handle touch input
canvas.addEventListener('touchstart', e => {
    if (isGameOver) return;
    e.preventDefault();
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
});

canvas.addEventListener('touchmove', e => {
    if (isGameOver || e.touches.length === 0) return;
    e.preventDefault();

    const touchEndX = e.touches[0].clientX;
    const touchEndY = e.touches[0].clientY;

    const dx = touchEndX - touchStartX;
    const dy = touchEndY - touchStartY;

    const sensitivity = 20;
    if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > sensitivity) {
        // Horizontal swipe
        if (dx > 0 && direction.x === 0) direction = { x: 1, y: 0 };
        else if (dx < 0 && direction.x === 0) direction = { x: -1, y: 0 };
    } else if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > sensitivity) {
        // Vertical swipe
        if (dy > 0 && direction.y === 0) direction = { x: 0, y: 1 };
        else if (dy < 0 && direction.y === 0) direction = { x: 0, y: -1 };
    }

    // Reset touch start position for continuous swiping
    touchStartX = touchEndX;
    touchStartY = touchEndY;
});

// Handle button clicks
controlsContainer.addEventListener('click', e => {
    if (isGameOver) return;

    const button = e.target.closest('.control-button');
    if (!button) return;

    const directionValue = button.getAttribute('data-direction');

    switch (directionValue) {
        case 'up':
            if (direction.y === 0) direction = { x: 0, y: -1 };
            break;
        case 'down':
            if (direction.y === 0) direction = { x: 0, y: 1 };
            break;
        case 'left':
            if (direction.x === 0) direction = { x: -1, y: 0 };
            break;
        case 'right':
            if (direction.x === 0) direction = { x: 1, y: 0 };
            break;
    }
});
